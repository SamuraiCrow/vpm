use anyhow::{Context, Result};
use std::process::Command;
use std::env;
use std::path::{Path, PathBuf};

use crate::cmd::{Execute, Run};

impl Execute for Run {
    fn execute(&self) -> Result<()> {
        // Compile the Verilog files using Icarus Verilog
        self.compile_verilog()?;

        // Run the simulation
        self.run_simulation()?;

        Ok(())
    }
}

impl Run {
    pub fn compile_verilog(&self) -> Result<()> {
        println!("Compiling Verilog files...");

        // Prepare the command to compile the Verilog files
        let mut command = Command::new("iverilog");
        command.arg("-o").arg(&self.output_name.trim_matches('"')); // Trim quotes if any

        // Add each Verilog file to the command
        for file in &self.verilog_files {
            command.arg(file);
        }

        // Execute the command
        let status = command.status().context("Failed to execute Icarus Verilog compilation")?;

        if !status.success() {
            eprintln!("Failed to compile Verilog files.");
            return Ok(());
        }

        // Create a trimmed output name for the path
        let trimmed_output_name = self.output_name.trim_matches('"');
        let output_path = Path::new(trimmed_output_name); // Create a Path from the trimmed output name

        // Check if the output binary exists
        if !output_path.exists() {
            eprintln!("Output binary not found: {:?}", output_path);
            return Ok(());
        }

        println!("Verilog files compiled successfully.");
        println!("Output binary created: {:?}", output_path);
        Ok(())
    }

    pub fn run_simulation(&self) -> Result<()> {
        println!("Running simulation...");
    
        // Print the current working directory
        let current_dir = env::current_dir().expect("Failed to get current directory");
        println!("Current working directory: {:?}", current_dir);
    
        // Create the binary path by concatenating the current directory with the output name
        let binary_path: PathBuf = current_dir.join(self.output_name.trim_matches('"')); // Trim quotes if any
        println!("Attempting to execute binary at: {:?}", binary_path);
    
        // Execute the simulation binary generated by Icarus Verilog
        let status = Command::new(&binary_path)
            .status()
            .context("Failed to execute simulation")?;
    
        if !status.success() {
            eprintln!("Simulation failed.");
            return Ok(());
        }
    
        println!("Simulation completed successfully.");
        Ok(())
    }
}

fn main() -> Result<()> {
    // Example command parsing (you may have your own command parsing logic)
    let args: Vec<String> = env::args().collect();

    if args.len() < 3 || args[1] != "run" {
        eprintln!("Usage: VPM run <output_name> <verilog_file1> <verilog_file2> ...");
        return Ok(());
    }

    // Collect the output name and Verilog files from the command line arguments
    let output_name = args[2].clone();
    let verilog_files = args[3..].to_vec();

    // Create an instance of Run and execute it
    let runner = Run {
        verilog_files,
        output_name,
    };

    runner.execute()?;

    Ok(())
}